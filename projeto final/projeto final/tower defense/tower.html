<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8">
   <link rel="stylesheet" href="estilo3t.css">
   <link rel="shortcut icon" type="imagen.png" href="torre.png"> 
   <title>Tower Defense</title>
 </head>
<body>
Â  <div id="custom-cursor"></div>

Â <div id="ui-container">
Â  Â  Â  Â  <div id="info-bar"> 
Â  Â  Â  Â  <div id="info-dinheiro"> Dinheiro: <span id="valorDinheiro">100</span></div>
Â Â  Â  Â  Â  <div id="info-rodada"> Rodada: <span id="valorRodada">1</span></div>
Â Â  Â  </div>

Â  Â  Â  Â  <div id="botoesTorres">
Â  Â  Â  Â  <button id="btnRemover"><img class="t" src="caracpnum (3).png" alt="Remover Torre"></button>
Â Â  Â  Â  Â <button id="btnTorre1"><img class="t" src="caracpnum.png" alt="Torre de fogo"></button>
Â  Â  Â  Â  <button id="btnTorre2"><img class="t" src="caracpnum (1).png" alt="Torre de Gelo"></button>
Â Â  Â  Â  Â <button id="btnTorre3"><img class="t" src="caracpnum (2).png" alt="Torre de Ouro"></button> 
Â  Â  Â  Â  <button id="btnIniciar"><img class="t" src="inicio.png" alt="inicio"></button> Â  Â  </div>
</div>

Â  <div id="map"><canvas></canvas></div>
 Â  Â  <script>
Â  // =====================
Â  // CURSOR PERSONALIZADO
Â  // =====================
Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  const cursor = document.getElementById('custom-cursor'); // Pega o elemento do cursor

Â  Â  // FunÃ§Ã£o para definir a imagem de fundo do cursor
Â  Â  function setCursor(imageUrl) {
Â  Â  Â  cursor.style.backgroundImage = `url('${imageUrl}')`;
Â  Â  }

Â  Â  // Move o cursor customizado para seguir o cursor real do mouse
Â  Â  document.addEventListener('mousemove', e => {
Â  Â  Â  cursor.style.left = e.clientX + 'px';
Â  Â  Â  cursor.style.top = e.clientY + 'px';
Â  Â  });

Â  Â  // Altera a imagem do cursor ao clicar (mousedown) e soltar (mouseup)
Â  Â  // âš ï¸ Altere os caminhos das imagens do cursor se necessÃ¡rio
Â  Â  document.addEventListener('mousedown', () => setCursor('../cursor2/link.gif'));
Â  Â  document.addEventListener('mouseup', () => setCursor('../cursor2/auto.gif'));

Â  Â  // Altera a imagem do cursor ao passar o mouse sobre um botÃ£o
Â  Â  document.addEventListener('mouseover', e => {
Â  Â  Â  const b = e.target.closest('button');
Â  Â  Â  if (b) setCursor('../cursor2/alternate.gif');
Â  Â  });
Â  Â  // Retorna a imagem do cursor ao sair de um botÃ£o
Â  Â  document.addEventListener('mouseout', e => {
Â  Â  Â  const b = e.target.closest('button');
Â  Â  Â  if (b) setCursor('../cursor2/auto.gif');
Â  Â  });
Â  });
Â  </script>

Â  Â  <script>
Â  // =====================
Â  // LÃ“GICA PRINCIPAL CORRIGIDA
Â  // =====================
Â  const valorDinheiroSpan=document.getElementById('valorDinheiro');
Â  const valorRodadaSpan=document.getElementById('valorRodada');
Â  const linhas=10,colunas=20,tamanhoCelula=60; // DimensÃµes do mapa e tamanho da cÃ©lula em pixels
Â  const GRAMA=0,TORRE=2,BASE=3,PORTAL=4; // Constantes para identificar o tipo de cÃ©lula no mapa (matriz)
Â  
Â  // VariÃ¡veis de estado do jogo
Â  // âœ… rodada comeÃ§a em 0 para que a primeira chamada a atualizarRodada() defina para 1
Â  let dinheiro=100,rodada=0,jogoIniciado=false,hordaAtiva=false;
Â  let gameOver = false;
Â  let modoRemocao = false; // Flag para o modo de remoÃ§Ã£o de torres
Â  let modotorre1 = false; // Flag para o modo de torre 1
  let modotorre2 = false; // Flag para o modo de torre 2
  let modotorre3 = false; // Flag para o modo de torre 3

Â  // Dados das torres disponÃ­veis para compra
Â  const torresDisponiveis=[
Â  Â  {id:"btnTorre1",tipo:1,dano:10,alcance:1.5,velocidade:60,custo:50,cor:'red',nome:"Torre de Fogo",cooldown:0, velocidadeBase: 60, danoBase: 10}, // Fogo: Dano de Ãrea ContÃ­nuo
Â  Â  {id:"btnTorre2",tipo:2,dano:5,alcance:3,velocidade:30,custo:70,cor:'blue',nome:"Torre de Gelo",cooldown:0, velocidadeBase: 30, danoBase: 5}, // Gelo: ProjÃ©til com Slow
Â  Â  {id:"btnTorre3",tipo:3,dano:0,alcance:2,velocidade:1,custo:120,cor:'gold',nome:"Torre de Ouro"} // Ouro: Gera dinheiro (sem dano)
Â  ];
Â  let torreSelecionada=torresDisponiveis[0]; // Torre padrÃ£o selecionada inicialmente
Â  const mapaTorres=[]; // Lista das torres atualmente colocadas no mapa
Â  
Â  // Define posiÃ§Ãµes aleatÃ³rias para o portal (inÃ­cio) e a base (fim)
Â  const portalLinha=Math.floor(Math.random()*linhas);
Â  const baseLinha=Math.floor(Math.random()*linhas);
Â  
Â  // Inicializa o mapa como uma matriz 2D preenchida com GRAMA
Â  const mapa=Array.from({length:linhas},()=>Array(colunas).fill(GRAMA));
Â  mapa[portalLinha][0]=PORTAL; // Define o portal (coluna 0)
Â  mapa[baseLinha][colunas-1]=BASE; // Define a base (coluna final)

Â  const inicio=[portalLinha,0],fim=[baseLinha,colunas-1]; // Coordenadas [linha, coluna] de inÃ­cio e fim
Â  
Â  // ConfiguraÃ§Ã£o do Canvas
Â  const canvas=document.querySelector("canvas");
Â  const ctx=canvas.getContext("2d");
Â  canvas.width=colunas*tamanhoCelula;
Â  canvas.height=linhas*tamanhoCelula;

Â  // A* - Algoritmo para encontrar o caminho mais curto para os inimigos
Â  
Â  // FunÃ§Ã£o heurÃ­stica (estimativa de distÃ¢ncia atÃ© o fim - Manhattan)
Â  function heuristica(a,b){return Math.abs(a[0]-b[0])+Math.abs(a[1]-b[1]);}
Â  
Â  // ImplementaÃ§Ã£o do algoritmo A*
Â  function astar(mapa,inicio,fim){
Â  Â  const aberto=[inicio],fechado=[],g=Array.from({length:linhas},
Â  Â  ()=>Array(colunas).fill(Infinity)),
Â  Â  f=Array.from({length:linhas},()=>Array(colunas).fill(Infinity)),
Â  Â  veio=Array.from({length:linhas},()=>Array(colunas).fill(null));

Â  Â  g[inicio[0]][inicio[1]]=0;f[inicio[0]][inicio[1]]=heuristica(inicio,fim);
Â  Â  while(aberto.length){
Â  Â  Â  let atual=aberto.reduce((a,b)=>f[a[0]][a[1]]<f[b[0]][b[1]]?a:b); // Encontra o nÃ³ com menor 'f'
Â  Â  Â  if(atual[0]===fim[0]&&atual[1]===fim[1]){ // Caminho encontrado
Â  Â  Â  Â  const c=[];let t=atual;while(t){c.push(t);t=veio[t[0]][t[1]];}return c.reverse(); // ReconstrÃ³i e retorna o caminho
Â  Â  Â  }
Â  Â  Â  aberto.splice(aberto.findIndex(p=>p[0]===atual[0]&&p[1]===atual[1]),1); // Remove de 'aberto'
Â  Â  Â  fechado.push(atual); // Adiciona a 'fechado'
Â  Â  Â  const viz=[ // Vizinhos ortogonais (cima, baixo, esquerda, direita)
Â  Â  Â  [atual[0]-1,atual[1]],
Â  Â  Â  [atual[0]+1,atual[1]],
Â  Â  Â  [atual[0],atual[1]-1],
Â  Â  Â  [atual[0],atual[1]+1]
Â  Â  ];

Â  Â  Â  for(const [l,c]of viz){
Â  Â  Â  Â  if(l<0||l>=linhas||c<0||c>=colunas)continue; // Verifica limites do mapa
Â  Â  Â  Â  // Torres (TORRE) sÃ£o consideradas obstÃ¡culos e nÃ£o podem ser atravessadas
Â  Â  Â  Â  if(mapa[l][c]===TORRE)continue; 
Â  Â  Â  Â  if(fechado.some(p=>p[0]===l&&p[1]===c))continue; // Pula se jÃ¡ estiver no fechado
Â  Â  Â  Â  const tent=g[atual[0]][atual[1]]+1; // Novo custo 'g' (distÃ¢ncia real)
Â  Â  Â  Â  if(!aberto.some(p=>p[0]===l&&p[1]===c))aberto.push([l,c]); // Adiciona ao aberto se for novo
Â  Â  Â  Â  else if(tent>=g[l][c])continue; // Pula se o novo caminho for pior
Â  Â  Â  Â  veio[l][c]=atual; // Atualiza o "pai" do nÃ³
Â  Â  Â  Â  g[l][c]=tent; // Atualiza 'g'
Â  Â  Â  Â  f[l][c]=tent+heuristica([l,c],fim); // Atualiza 'f' = g + h
Â  Â  Â  }
Â  Â  }
Â  Â  return[]; // Retorna vazio se nÃ£o encontrar caminho
Â  }
Â  
Â  // âœ… 1. Salva o caminho padrÃ£o ANTES de qualquer torre ser colocada
Â  const caminhoPadrao = astar(mapa, inicio, fim); 
Â  let caminhoAEstrela = caminhoPadrao; // Caminho ativo, que serÃ¡ recalculado
Â  
Â  // Listas de elementos ativos no jogo
Â  const inimigos=[],projeteis=[];
Â  
Â  // Dados base dos tipos de inimigo
Â  const tiposInimigoBase=[
Â  Â  {nome:"Comum",vidaBase:40,vida:40,vel:0.5,qtdBase:8,qtd:8,recompensa:10,cor:"#7CFC00"},
Â  Â  {nome:"MÃ©dio",vidaBase:60,vida:60,vel:1,qtdBase:3,qtd:3,recompensa:25,cor:"#FFA500"},
Â  Â  {nome:"Destruidor",vidaBase:80,vida:80,vel:1.2,qtdBase:1,qtd:1,recompensa:40,cor:"#9400D3"} 
Â  ];

Â  // Atualiza o valor do dinheiro na UI e aplica um efeito visual
Â  function atualizarDinheiro(v){
Â  Â  dinheiro+=v;
Â  Â  valorDinheiroSpan.textContent=dinheiro;
Â  Â  valorDinheiroSpan.classList.add("valorAtualizado");
Â  Â  setTimeout(() => valorDinheiroSpan.classList.remove("valorAtualizado"), 500);
Â  }
Â  
Â  // Incrementa e atualiza o nÃºmero da rodada na UI
Â  function atualizarRodada(){
Â  Â  rodada++;
Â  Â  valorRodadaSpan.textContent=rodada;
Â  }

// FunÃ§Ã£o principal de desenho do mapa e elementos
function desenharMapa() {
Â  ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas

Â  // 1ï¸âƒ£ Desenha a grama de fundo e a grade
Â  for (let l = 0; l < linhas; l++) {
Â  Â  for (let c = 0; c < colunas; c++) {
Â  Â  Â  ctx.fillStyle = '#75a12a'; // Cor da grama
Â  Â  Â  ctx.fillRect(c * tamanhoCelula, l * tamanhoCelula, tamanhoCelula, tamanhoCelula);
Â  Â  Â  ctx.strokeStyle = '#66855f'; // Cor da grade
Â  Â  Â  ctx.strokeRect(c * tamanhoCelula, l * tamanhoCelula, tamanhoCelula, tamanhoCelula);
Â  Â  }
Â  }

Â  // 2ï¸âƒ£ Desenha o caminho atual (recalculado pelo A*)
Â  ctx.fillStyle = '#006400'; // Cor do caminho
Â  for (const [l, c] of caminhoAEstrela) {
Â  Â  ctx.fillRect(c * tamanhoCelula, l * tamanhoCelula, tamanhoCelula, tamanhoCelula);
Â  }

Â  // 3ï¸âƒ£ Desenha PORTAL, BASE e TORRES (blocos)
Â  for (let l = 0; l < linhas; l++) {
Â  Â  for (let c = 0; c < colunas; c++) {
Â  Â  Â  const x = c * tamanhoCelula;
Â  Â  Â  const y = l * tamanhoCelula;

Â  Â  Â  if (mapa[l][c] === BASE) {
Â  Â  Â  Â  ctx.fillStyle = 'gray'; // Cor da Base
Â  Â  Â  Â  ctx.fillRect(x, y, tamanhoCelula, tamanhoCelula);
Â  Â  Â  } else if (mapa[l][c] === PORTAL) {
Â  Â  Â  Â  ctx.fillStyle = '#682cf5'; // Cor do Portal
Â  Â  Â  Â  ctx.fillRect(x, y, tamanhoCelula, tamanhoCelula);
Â  Â  Â  } else if (mapa[l][c] === TORRE) {
Â  Â  Â  Â  const t = mapaTorres.find(t => t.linha === l && t.coluna === c); // Encontra a torre
Â  Â  Â  Â  // ğŸ¨ Desenha a torre como um QUADRADO
Â  Â  Â  Â  ctx.fillStyle = t ? t.cor : '#444'; // Cor da torre (usa a cor definida na torre)
Â  Â  Â  Â  
Â  Â  Â  Â  const tamanhoTorre = tamanhoCelula * 0.7; 
Â  Â  Â  Â  const offset = (tamanhoCelula - tamanhoTorre) / 2; // Centraliza o quadrado
Â  Â  Â  Â  
Â  Â  Â  Â  ctx.fillRect(x + offset, y + offset, tamanhoTorre, tamanhoTorre);
Â  Â  Â  }
Â  Â  }
Â  }

// ğŸ¯ Desenhar a Ã¡rea de alcance das torres (visualizaÃ§Ã£o)
mapaTorres.forEach(torre => {
Â  // Torre de ouro nÃ£o ataca e, portanto, nÃ£o desenha alcance
Â  if (torre.tipo === 3 || !torre.alcance) return;

Â  const centroX = torre.coluna * tamanhoCelula + tamanhoCelula / 2;
Â  const centroY = torre.linha * tamanhoCelula + tamanhoCelula / 2;
Â  const raio = torre.alcance * tamanhoCelula; // Alcance em pixels

Â  // Verifica se hÃ¡ inimigo dentro do raio para mudar a cor
Â  const inimigoProximo = inimigos.some(i => {
Â  Â  const dx = i.x - centroX;
Â  Â  const dy = i.y - centroY;
Â  Â  return Math.sqrt(dx * dx + dy * dy) <= raio;
Â  });

Â  // Define a cor da Ã¡rea de alcance
Â  ctx.fillStyle = inimigoProximo 
Â  Â  Â  ? "rgba(255, 0, 0, 0.4)" Â  // Vermelho forte se estiver atacando
Â  Â  Â  : "rgba(232, 247, 250, 0.2)"; // Azul claro/transparente (ou vermelho suave)
Â  
Â  if(torre.tipo === 2) { // Cor especÃ­fica para Torre de Gelo
Â  Â  ctx.fillStyle = "rgba(100, 100, 255, 0.2)"; 
Â  }

Â  ctx.beginPath();
Â  ctx.arc(centroX, centroY, raio, 0, Math.PI * 2); // Desenha o cÃ­rculo
Â  ctx.fill();
Â  ctx.closePath();
});

Â  // 5ï¸âƒ£ Desenha inimigos
Â  inimigos.forEach(i => {
Â  Â  // âš ï¸ Se o inimigo estiver sob efeito Slow, desenha azul claro, senÃ£o usa a cor original
Â  Â  ctx.fillStyle = i.slow > 0 ? "rgba(0, 200, 255, 0.7)" : i.tipo.cor;
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(i.x, i.y, 12, 0, Math.PI * 2); // Desenha o inimigo como um cÃ­rculo
Â  Â  ctx.fill();
Â  Â  ctx.closePath();

Â  Â  // Desenha a barra de vida
Â  Â  const larguraBarra = 30;
Â  Â  ctx.fillStyle = "red";
Â  Â  // O preenchimento da vida Ã© proporcional Ã  vida atual/mÃ¡xima
Â  Â  ctx.fillRect(i.x - 15, i.y - 20, larguraBarra * (i.vida / i.vidaMax), 4);
Â  Â  ctx.strokeStyle = "black";
Â  Â  ctx.strokeRect(i.x - 15, i.y - 20, larguraBarra, 4); // Contorno da barra de vida
Â  });

Â  // 6ï¸âƒ£ Desenha os projÃ©teis
Â  projeteis.forEach(p => {
Â  Â  ctx.fillStyle = p.cor || 'cyan'; // Cor padrÃ£o ciano
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
Â  Â  ctx.fill();
Â  Â  ctx.closePath();
Â  });
}

// O Loop Principal do Jogo (FPS)
function gameLoop(){
Â  Â  if(!jogoIniciado) return; // Se o jogo nÃ£o foi iniciado (ou deu Game Over), para o loop

Â  Â  moverInimigos(); // Move inimigos e projÃ©teis (tambÃ©m chama desenharMapa)
Â  Â  atacarInimigos(); // Lida com o disparo das torres

Â  Â  requestAnimationFrame(gameLoop); // âœ… Usa requestAnimationFrame para um loop suave
}

Â  // LÃ³gica de movimento dos inimigos
Â  function moverInimigos(){
Â  Â  // Loop reverso para remoÃ§Ã£o segura de inimigos
Â  Â  for(let idx = inimigos.length - 1; idx >= 0; idx--){
Â  Â  Â  const i = inimigos[idx];
Â  Â  Â  const caminho=i.caminho; // Caminho A* atual do inimigo

Â  Â  Â  if(i.pos>=caminho.length-1){
Â  Â  Â  Â  // Inimigo chegou Ã  base: Game Over
Â  Â  Â  Â  inimigos.splice(idx,1);
Â  Â  Â  Â  
Â  Â  Â  Â  // ğŸ’¥ LÃ³gica de Game Over
Â  Â  Â  Â  if (!gameOver) { 
Â  Â  Â  Â  Â  gameOver = true;
Â  Â  Â  Â  Â  jogoIniciado = false; 
Â  Â  Â  Â  Â  console.log("GAME OVER! Inimigo chegou Ã  base.");
Â  Â  Â  Â  Â  alert("VOCÃŠ PERDEU! Um inimigo chegou atÃ© a base. Rodada final: " + rodada);
Â  Â  Â  Â  Â  location.reload(); // Reinicia a pÃ¡gina
Â  Â  Â  Â  }
Â  Â  Â  Â  continue;
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  // âœ… 8. Aplica o Slow
Â  Â  Â  let velAtual = i.tipo.vel;
Â  Â  Â  if(i.slow > 0) {
Â  Â  Â  Â  velAtual *= 0.5; // Reduz a velocidade pela metade
Â  Â  Â  Â  i.slow--; // Decrementa o contador de frames do slow
Â  Â  Â  }

Â  Â  Â  const alvo=caminho[i.pos+1]; // PrÃ³xima cÃ©lula no caminho
Â  Â  Â  // Calcula a distÃ¢ncia e direÃ§Ã£o atÃ© o centro da prÃ³xima cÃ©lula
Â  Â  Â  const dx=alvo[1]*tamanhoCelula+tamanhoCelula/2-i.x;
Â  Â  Â  const dy=alvo[0]*tamanhoCelula+tamanhoCelula/2-i.y;
Â  Â  Â  const dist=Math.sqrt(dx*dx+dy*dy);
Â  Â  Â  
Â  Â  Â  if(dist<velAtual){ // Se estiver perto o suficiente, avanÃ§a para a prÃ³xima cÃ©lula
Â  Â  Â  Â  i.pos++;
Â  Â  Â  Â  
Â  Â  Â  Â  // 7. LÃ³gica do Destruidor: destrÃ³i a torre se entrar na cÃ©lula dela
Â  Â  Â  Â  if(i.tipo.nome==="Destruidor de Torres"){
Â  Â  Â  Â  Â  const [l, c] = caminho[i.pos]; // CÃ©lula atual
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  const torreDestruirIndex = mapaTorres.findIndex(t => t.linha === l && t.coluna === c);

Â  Â  Â  Â  Â  if(torreDestruirIndex !== -1){
Â  Â  Â  Â  Â  Â  // âœ… 5. RemoÃ§Ã£o da torre do mapa e da lista de torres
Â  Â  Â  Â  Â  Â  const t = mapaTorres[torreDestruirIndex];
Â  Â  Â  Â  Â  Â  mapa[t.linha][t.coluna] = GRAMA; // Libera o espaÃ§o
Â  Â  Â  Â  Â  Â  mapaTorres.splice(torreDestruirIndex, 1);
Â  Â  Â  Â  Â  Â  console.log("ğŸ’¥ Torre destruÃ­da pelo inimigo destruidor!");
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Recalcula o caminho A* para o novo mapa
Â  Â  Â  Â  Â  Â  caminhoAEstrela = astar(mapa, inicio, fim);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  }else{
Â  Â  Â  Â  // Move o inimigo na direÃ§Ã£o do alvo
Â  Â  Â  Â  i.x+=(dx/dist)*velAtual;
Â  Â  Â  Â  i.y+=(dy/dist)*velAtual;
Â  Â  Â  }
Â  Â  }
Â  Â  moverProjeteis(); // Move os projÃ©teis apÃ³s mover os inimigos
Â  Â  desenharMapa(); // Redesenha o mapa (inimigos em nova posiÃ§Ã£o)
Â  }
Â 
Â  // LÃ³gica de movimento e colisÃ£o de projÃ©teis
Â  function moverProjeteis(){
Â  Â  // Loop reverso para remoÃ§Ã£o segura de projÃ©teis
Â  Â  for(let idx = projeteis.length - 1; idx >= 0; idx--){
Â  Â  Â  const p = projeteis[idx];
Â  Â  Â  
Â  Â  Â  // Remove projÃ©teis se o alvo nÃ£o existir ou estiver morto
Â  Â  Â  if(!p.alvo || p.alvo.vida <= 0){
Â  Â  Â  Â  projeteis.splice(idx,1);
Â  Â  Â  Â  continue;
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  // Calcula a distÃ¢ncia e direÃ§Ã£o atÃ© o alvo
Â  Â  Â  const dx=p.alvo.x-p.x,dy=p.alvo.y-p.y,dist=Math.sqrt(dx*dx+dy*dy);
Â  Â  Â  
Â  Â  Â  if(dist<6){ // ColisÃ£o: projÃ©til atingiu o alvo
Â  Â  Â  Â  p.alvo.vida-=p.dano; // Aplica o dano
Â  Â  Â  Â  
Â  Â  Â  Â  // Aplica slow se for Torre de Gelo (tipo 2)
Â  Â  Â  Â  if(p.tipo === 2) p.alvo.slow = 120; // 120 frames de slow (~2 segundos a 60 FPS)
Â  Â  Â  Â  
Â  Â  Â  Â  projeteis.splice(idx,1); // Remove o projÃ©til
Â  Â  Â  Â  
Â  Â  Â  Â  // Se o alvo morreu
Â  Â  Â  Â  if(p.alvo.vida<=0){
Â  Â  Â  Â  Â  atualizarDinheiro(p.alvo.tipo.recompensa); // Adiciona dinheiro
Â  Â  Â  Â  Â  // Encontra e remove o inimigo da lista
Â  Â  Â  Â  Â  const inimigoIdx = inimigos.indexOf(p.alvo);
Â  Â  Â  Â  Â  if(inimigoIdx !== -1) inimigos.splice(inimigoIdx, 1);
Â  Â  Â  Â  }
Â  Â  Â  }else{
Â  Â  Â  Â  // Move o projÃ©til em direÃ§Ã£o ao alvo
Â  Â  Â  Â  p.x+=(dx/dist)*8; // Velocidade fixa do projÃ©til
Â  Â  Â  Â  p.y+=(dy/dist)*8;
Â  Â  Â  }
Â  Â  }
Â  }

Â  // LÃ³gica de ataque das torres
Â  function atacarInimigos(){
Â  Â  mapaTorres.forEach(t=>{
Â  Â  Â  t.cooldown--; // Diminui o cooldown (para torres de projÃ©teis)
Â  Â  Â  
Â  Â  Â  // Centro da torre e raio de alcance em pixels
Â  Â  Â  const cx=t.coluna*tamanhoCelula+tamanhoCelula/2;
Â  Â  Â  const cy=t.linha*tamanhoCelula+tamanhoCelula/2;
Â  Â  Â  const raio=t.alcance*tamanhoCelula;
Â  Â  Â  
Â  Â  Â  if(t.tipo === 1){ // ğŸ”¥ Torre de Fogo (Dano ContÃ­nuo de Ãrea)
Â  Â  Â  Â  for (let idx = inimigos.length - 1; idx >= 0; idx--) {
Â  Â  Â  Â  Â  const i = inimigos[idx];
Â  Â  Â  Â  Â  // Verifica se o inimigo estÃ¡ dentro do alcance (hipotenusa)
Â  Â  Â  Â  Â  if(Math.hypot(i.x-cx,i.y-cy)<=raio){
Â  Â  Â  Â  Â  Â  i.vida-=t.dano * 0.05; // Dano por frame (5% do dano)
Â  Â  Â  Â  Â  Â  if(i.vida<=0){
Â  Â  Â  Â  Â  Â  Â  atualizarDinheiro(i.tipo.recompensa);
Â  Â  Â  Â  Â  Â  Â  inimigos.splice(idx,1); // âœ… RemoÃ§Ã£o segura de inimigos mortos
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  if(t.tipo === 2){ // â„ï¸ Torre de Gelo (Projetil com Slow)
Â  Â  Â  Â  if(t.cooldown <= 0){ // Pronto para atirar
Â  Â  Â  Â  Â  // Encontra o primeiro alvo dentro do alcance
Â  Â  Â  Â  Â  const alvo=inimigos.find(i=>Math.hypot(i.x-cx,i.y-cy)<=raio);
Â  Â  Â  Â  Â  if(alvo){
Â  Â  Â  Â  Â  Â  // Cria um novo projÃ©til
Â  Â  Â  Â  Â  Â  projeteis.push({x:cx,y:cy,alvo,dano:t.dano, tipo: 2}); 
Â  Â  Â  Â  Â  Â  t.cooldown = t.velocidade; // Reseta o cooldown (velocidade de ataque)
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  });
Â  }

Â  // GeraÃ§Ã£o de dinheiro da Torre de Ouro (tipo 3) - Usa setInterval para tempo fixo
Â  setInterval(()=>{
Â  Â  // Filtra apenas as torres de Ouro e gera 5 de dinheiro para cada uma a cada 2 segundos
Â  Â  mapaTorres.filter(t=>t.tipo===3).forEach(()=>atualizarDinheiro(5));
Â  },2000);

// FunÃ§Ã£o para gerar inimigos em sequÃªncia
function iniciarHorda() {
      Â  if (hordaAtiva) return; // Evita iniciar hordas sobrepostas

Â  atualizarRodada(); // Incrementa e atualiza a rodada
Â  hordaAtiva = true;

if (rodada % 5 === 0 && rodada > 0) {
    const nivelAprimoramento = Math.floor(rodada / 5);
    const fatorReducao = 1 - (nivelAprimoramento * 0.1); 
    const fatorAumentoDano = 1 + (nivelAprimoramento * 0.1); 

    mapaTorres.forEach(torre => {
        // Obter os valores base, garantindo que existam.
        const danoBase = torre.danoBase || torre.dano; // Garante o valor base
        const velocidadeBase = torre.velocidadeBase || torre.velocidade; // Garante o valor base

        if (torre.tipo === 1 || torre.tipo === 2) {
            // 1. Aprimoramento de Dano (Torres 1 e 2)
            // Multiplica o DANO BASE pelo fator de aumento (crescimento linear)
            torre.dano = danoBase * fatorAumentoDano; 
        }
        
        if (torre.tipo === 2) {
            // 2. Aprimoramento de Velocidade (Torre 2 - Gelo)
            // Multiplica a VELOCIDADE BASE pelo fator de reduÃ§Ã£o.
            // O Math.max(5, ...) garante um limite mÃ­nimo de velocidade de ataque.
            torre.velocidade = Math.max(5, velocidadeBase * fatorReducao); 
        }
    });
}
    // === LÃ“GICA CORRIGIDA DE APRIMORAMENTO DE INIMIGOS (VIDA E QUANTIDADE) ===
    if (rodada > 0) { // Aprimora a cada rodada
        const nivelAprimoramento = rodada;
        const fatorVida = 1 + (nivelAprimoramento * 1.1); 
        const fatorQuantidade = 1 + (nivelAprimoramento * 1.05); 

        tiposInimigoBase.forEach(tipoInimigo => {
            // A vida mÃ¡xima (vidaMax) deve ser ajustada para o inimigo ser "resetado" na prÃ³xima rodada
            // e a propriedade 'vida' do objeto base deve ser o novo valor.
            tipoInimigo.vida = Math.round(tipoInimigo.vidaBase * fatorVida); 
            tipoInimigo.qtd = Math.round(tipoInimigo.qtdBase * fatorQuantidade); 
        });
    }
Â  // ===============================================================

Â  // === LÃ³gica de SPWN da Horda: CRIA OS INIMIGOS ===
Â  // Spawna todos os tipos de inimigo definidos
Â  tiposInimigoBase.forEach(tipo => spawnInimigos(tipo));Â  
Â  // ===================================================

Â  // ğŸ”¥ LÃ³gica para o tempo de duraÃ§Ã£o da horda e intervalo entre hordas
Â  const duracaoBase = 8000; 
Â  const intervaloBase = 3000; 

Â  // Diminui o tempo conforme as rodadas avanÃ§am
Â  const duracaoHorda = Math.max(3000, duracaoBase - rodada * 400); 
Â  const intervaloHorda = Math.max(800, intervaloBase - rodada * 200);

Â  // Define quando a horda termina e quando a prÃ³xima comeÃ§a
Â  setTimeout(() => {
Â  Â  hordaAtiva = false;
Â  Â  
Â  Â  // Inicia a prÃ³xima rodada automaticamente se o jogo estiver rodando
Â  Â  if(jogoIniciado) setTimeout(iniciarHorda, intervaloHorda);
Â  }, duracaoHorda);
}

// FunÃ§Ã£o para gerar inimigos em sequÃªncia
function spawnInimigos(tipo) {
Â  let contador = 0;
Â  const intervalo = setInterval(() => {
Â  Â  if (contador >= tipo.qtd) {
Â  Â  Â  clearInterval(intervalo);
Â  Â  Â  return;
Â  Â  }

Â  Â  // Cria um novo objeto inimigo
Â  Â  const inimigo = {
      tipo,
      qtd: tipo.qtd, // Ajusta a quantidade por rodada
Â  Â  Â  vida: tipo.vida,
Â  Â  Â  vidaMax: tipo.vida,
Â  Â  Â  pos: 0, // PosiÃ§Ã£o inicial no caminho
Â  Â  Â  // PosiÃ§Ã£o em pixels no centro do portal
Â  Â  Â  x: inicio[1] * tamanhoCelula + tamanhoCelula / 2,
Â  Â  Â  y: inicio[0] * tamanhoCelula + tamanhoCelula / 2,
Â  Â  Â  // âœ… Inimigos usam o caminho A* atual
Â  Â  Â  caminho: caminhoAEstrela, 
Â  Â  Â  slow: 0 
Â  Â  };

Â  Â  inimigos.push(inimigo);
Â  Â  contador++;
Â  }, 1000); // Spawna um inimigo a cada 1 segundo (por tipo)
}

Â  // Event Listener para o clique no mapa (colocar/remover torres)
Â  canvas.addEventListener('click',e=>{
Â  Â  const rect=canvas.getBoundingClientRect();
Â  Â  // Converte a posiÃ§Ã£o do clique em coordenadas de cÃ©lula (coluna e linha)
Â  Â  const c=Math.floor((e.clientX-rect.left)/tamanhoCelula);
Â  Â  const l=Math.floor((e.clientY-rect.top)/tamanhoCelula);

// === LÃ“GICA DE REMOÃ‡ÃƒO DA TORRE (Venda) ===
Â  Â  if (modoRemocao && mapa[l][c] === TORRE) {
Â  Â  Â  Â  const index = mapaTorres.findIndex(t => t.linha === l && t.coluna === c);
Â  Â  Â  Â  if (index !== -1) {
Â  Â  Â  Â  Â  Â  const torreRemovida = mapaTorres.splice(index, 1)[0];
Â  Â  Â  Â  Â  Â  mapa[l][c] = GRAMA; // Libera o espaÃ§o
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Reembolso de 50% do custo base
Â  Â  Â  Â  Â  Â  const torreBase = torresDisponiveis.find(t => t.tipo === torreRemovida.tipo);
Â  Â  Â  Â  Â  Â  const reembolso = Math.floor(torreBase.custo * 0.5); 
Â  Â  Â  Â  Â  Â  atualizarDinheiro(reembolso);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Recalcula o caminho A* apÃ³s a remoÃ§Ã£o
Â  Â  Â  Â  Â  Â  caminhoAEstrela = astar(mapa, inicio, fim); 
Â  Â  Â  Â  Â  Â  console.log(`Torre vendida! Reembolso de ${reembolso}.`);
Â  Â  Â  Â  }
Â  Â  Â  Â  desenharMapa();
Â  Â  Â  Â  return; // Encerra o clique no modo remoÃ§Ã£o
Â  Â  }
Â  Â  // ===================================
Â  Â  
Â  Â  // Tenta colocar a torre se for grama e se tiver dinheiro
Â  Â  if(mapa[l][c]===GRAMA&&dinheiro>=torreSelecionada.custo){
Â  Â  Â  
Â  Â  Â  // 1. Simula a colocaÃ§Ã£o da torre no mapa (temporariamente)
Â  Â  Â  mapa[l][c]=TORRE;
Â  Â  Â  const novoCaminho=astar(mapa,inicio,fim); // Tenta calcular o novo caminho
Â  Â  Â  
Â  Â  Â  if(novoCaminho.length>0){
Â  Â  Â  Â  // 2. Sucesso: caminho vÃ¡lido, confirma a colocaÃ§Ã£o
Â  Â  Â  Â  // Cria uma cÃ³pia da torre selecionada e adiciona ao mapaTorres
Â  Â  Â  Â  mapaTorres.push({...torreSelecionada,linha:l,coluna:c}); 
Â  Â  Â  Â  atualizarDinheiro(-torreSelecionada.custo);
Â  Â  Â  Â  caminhoAEstrela=novoCaminho; // Atualiza o caminho ativo
Â  Â  Â  Â  desenharMapa();
Â  Â  Â  }else{
Â  Â  Â  Â  // 3. Falha: caminho bloqueado
Â  Â  Â  Â  mapa[l][c]=GRAMA; // Desfaz a simulaÃ§Ã£o
Â  Â  Â  Â  console.log("âš ï¸ Caminho bloqueado! Inimigo destruidor ativado!");
Â  Â  Â  Â  
Â  Â  Â  Â  // Ativa um inimigo Destruidor
Â  Â  Â  Â  const destruidor={
Â  Â  Â  Â  Â  tipo:{nome:"Destruidor de Torres",vida:9999,vel:2,recompensa:0,cor:"#ff0000"},
Â  Â  Â  Â  Â  vida:9999,vidaMax:9999,pos:0,
Â  Â  Â  Â  Â  caminho: caminhoPadrao, // âœ… O Destruidor usa o caminho PadrÃ£o (sem a torre que bloqueia)
Â  Â  Â  Â  Â  x:inicio[1]*tamanhoCelula+tamanhoCelula/2,
Â  Â  Â  Â  Â  y:inicio[0]*tamanhoCelula+tamanhoCelula/2
Â  Â  Â  Â  };
Â  Â  Â  Â  inimigos.push(destruidor);
Â  Â  Â  }
Â  Â  }
Â  });

// LÃ³gica para o botÃ£o de remoÃ§Ã£o
Â  document.getElementById('btnRemover').onclick = () => {
Â  Â  // 1. Alterna o estado de remoÃ§Ã£o
Â  Â  modoRemocao = !modoRemocao;

Â  Â  // 2. Atualiza o visual e o estado
Â  Â  if (modoRemocao) {
Â  Â  Â  Â  document.getElementById('btnRemover').classList.add('active'); // Destaque no CSS
Â  Â  Â  Â  torreSelecionada = null; // Impede a colocaÃ§Ã£o de torres
Â  Â  Â  Â  console.log("Modo RemoÃ§Ã£o ativado. Clique em uma torre para vender.");
Â  Â  } else {
Â  Â  Â  Â  document.getElementById('btnRemover').classList.remove('active');
Â  Â  Â  Â  torreSelecionada = torresDisponiveis[0]; // Volta para a seleÃ§Ã£o de torre padrÃ£o
Â  Â  Â  Â  console.log("Modo RemoÃ§Ã£o desativado.");
Â  Â  }
Â  Â  desenharMapa();
};

// LÃ³gica para o botÃ£o de remoÃ§Ã£o
Â  document.getElementById('btnTorre1').onclick = () => {
Â  Â  // 1. Alterna o estado de torre1
Â  Â  modotorre1 = !modotorre1;

Â  Â  // 2. Atualiza o visual e o estado
Â  Â  if (modotorre1) {
Â  Â  Â  Â  document.getElementById('btnTorre1').classList.add('active'); // Destaque no CSS
Â  Â  Â  Â  torreSelecionada = torresDisponiveis[0]; // Volta para a seleÃ§Ã£o de torre padrÃ£o 
Â  Â  Â  Â  console.log("Clique para colocar uma torre.");
Â  Â  } else {
Â  Â  Â  Â  document.getElementById('btnTorre1').classList.remove('active');
Â  Â  Â  Â  torreSelecionada = null; // Impede a colocaÃ§Ã£o de torres
Â  Â  Â  Â  console.log("Desativado.");
Â  Â  }
Â  Â  desenharMapa();
};

// LÃ³gica para o botÃ£o de remoÃ§Ã£o
Â  document.getElementById('btnTorre2').onclick = () => {
Â  Â  // 1. Alterna o estado de torre2
Â  Â  modotorre2 = !modotorre2;

Â  Â  // 2. Atualiza o visual e o estado
Â  Â  if (modotorre2) {
Â  Â  Â  Â  document.getElementById('btnTorre2').classList.add('active'); // Destaque no CSS
Â  Â  Â  Â  torreSelecionada = torresDisponiveis[1]; // Volta para a seleÃ§Ã£o de torre padrÃ£o 
Â  Â  Â  Â  console.log("Clique para colocar uma torre.");
Â  Â  } else {
Â  Â  Â  Â  document.getElementById('btnTorre2').classList.remove('active');
Â  Â  Â  Â  torreSelecionada = null; // Impede a colocaÃ§Ã£o de torres
Â  Â  Â  Â  console.log("Desativado.");
Â  Â  }
Â  Â  desenharMapa();
};

// LÃ³gica para o botÃ£o de remoÃ§Ã£o
Â  document.getElementById('btnTorre3').onclick = () => {
Â  Â  // 1. Alterna o estado de torre3
Â  Â  modotorre3 = !modotorre3;

Â  Â  // 2. Atualiza o visual e o estado
Â  Â  if (modotorre3) {
Â  Â  Â  Â  document.getElementById('btnTorre3').classList.add('active'); // Destaque no CSS
Â  Â  Â  Â  torreSelecionada = torresDisponiveis[2]; // Volta para a seleÃ§Ã£o de torre padrÃ£o 
Â  Â  Â  Â  console.log("Clique para colocar uma torre.");
Â  Â  } else {
Â  Â  Â  Â  document.getElementById('btnTorre3').classList.remove('active');
Â  Â  Â  Â  torreSelecionada = null; // Impede a colocaÃ§Ã£o de torres
Â  Â  Â  Â  console.log("Desativado.");
Â  Â  }
Â  Â  desenharMapa();
};

Â  // LÃ³gica para o botÃ£o Iniciar
Â  document.getElementById('btnIniciar').onclick=()=>{
Â  Â  // âœ… Se o jogo nÃ£o estiver iniciado, inicia o loop e a primeira horda
Â  Â  if(!jogoIniciado){
Â  Â  Â  jogoIniciado=true;
Â  Â  Â  iniciarHorda();
Â  Â  Â  gameLoop(); // Inicia o loop principal de animaÃ§Ã£o e lÃ³gica
      document.getElementById('btnIniciar').classList.add('active');
Â  Â  }
Â  };
Â  // Atribui a funÃ§Ã£o de seleÃ§Ã£o de torre a cada botÃ£o de torre
Â  torresDisponiveis.forEach(t=>document.getElementById(t.id).onclick=()=>torreSelecionada=t);
Â  
Â  desenharMapa(); // Desenha o mapa inicial
Â  </script>
</body>
</html>